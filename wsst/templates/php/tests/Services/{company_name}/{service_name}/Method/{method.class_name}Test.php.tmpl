<?php

/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */

/**
 * Test case for the class "<%[$package_name]%>_Method_<%[$method{class_name}]%>"
 *
 * PHP versions 5
<%[ if ($php_license_abstract) {
    $OUT .= " *\n";
    $php_license_abstract =~ s/^\s+//;
    $php_license_abstract =~ s/\s+$//;
    $php_license_abstract =~ s/\n/\n * /g;
    $OUT .= " * LICENSE: $php_license_abstract\n";
} ]%> *
 * @category   Services
 * @package    <%[$package_name]%>
<%[ foreach (@author) {
    $OUT .= " * \@author     $_\n";
} ]%><%[ if ($php_copyright||$copyright) {
    local $copyright = ($php_copyright||$copyright);
    $OUT .= " * \@copyright  $copyright\n";
} ]%> * @license    <%[$php_license_uri]%> <%[$license]%>
 * @version    Release: @package_version@
 * @link       <%[$php_link]%>
 */

require_once 'PEAR.php';
require_once 'PHPUnit/Framework.php';
require_once '<%[$package_dir]%>/Method/<%[$method{class_name}]%>.php';
require_once '<%[$package_dir]%>/Factory.php';

/**
 * Test class for <%[$package_name]%>_Method_<%[$method{class_name}]%>
 *
 * @category   Services
 * @package    <%[$package_name]%>
<%[ foreach (@author) {
    $OUT .= " * \@author     $_\n";
} ]%><%[ if ($php_copyright||$copyright) {
    local $copyright = ($php_copyright||$copyright);
    $OUT .= " * \@copyright  $copyright\n";
} ]%> * @license    <%[$php_license_uri]%> <%[$license]%>
 * @version    Release: @package_version@
 * @link       <%[$php_link]%>
 */
class <%[$package_name]%>_Method_<%[$method{class_name}]%>Test extends PHPUnit_Framework_TestCase
{
    protected $factory;
	
    public function setUp()
    {
        $this->factory = new <%[$package_name]%>_Factory();
    }
	
    public function testNew()
    {
        $obj = new <%[$package_name]%>_Method_<%[$method{class_name}]%>($this->factory);
        $this->assertNotNull($obj);
    }
    
    public function testGetUrl()
    {
        $obj = new <%[$package_name]%>_Method_<%[$method{class_name}]%>($this->factory);
        $this->assertEquals('<%[$method{url}]%>', $obj->getUrl());
    }
    
    public function testGetParamsConf()
    {
    	$obj = new <%[$package_name]%>_Method_<%[$method{class_name}]%>($this->factory);
    	$conf = $obj->getParamsConf();
    	$this->assertType('array', $conf);
    	if ($conf['defaults']) {
    	    $this->assertType('array', $conf['defaults']);
    	    $this->assertNull($conf['defaults'][0]);
    	}
    	if ($conf['fixed']) {
    	    $this->assertType('array', $conf['fixed']);
    	    $this->assertNull($conf['fixed'][0]);
    	}
    	if ($conf['keys']) {
    	    $this->assertType('array', $conf['keys']);
    	    $this->assertNotNull($conf['keys'][0]);
    	}
    	if ($conf['notnull']) {
    	    $this->assertType('array', $conf['notnull']);
    	    $this->assertNotNull($conf['notnull'][0]);
    	}
    }
    
    public function testGetResponseConf()
    {
        $obj = new <%[$package_name]%>_Method_<%[$method{class_name}]%>($this->factory);
        $conf = $obj->getResponseConf();
        $this->assertType('array', $conf);
        if ($conf['force_array']) {
            $this->assertType('array', $conf['force_array']);
            $this->assertNotNull($conf['force_array'][0]);
        }
    }
    
    public function testExecute()
    {
        $obj = new <%[$package_name]%>_Method_<%[$method{class_name}]%>($this->factory);
<%[ for (my $i = 0; $i < @{$method{tests}}; $i++) {
    my $test = $method{tests}->[$i];
    my $name = $test->{name} || "Test[$i]";

    $OUT .= "\n";
    $OUT .= "        // $name\n";
    $OUT .= "        \$params = array(\n";
    foreach my $key (sort keys %{$test->{params}}) {
        my $val = $test->{params}->{$key};
        unless ($val =~ s/^\$(.*)$/getenv('$1')/) {
            $val = "'$val'";
        }
        $OUT .= "            '$key' => $val,\n";
    }
    $OUT .= "        );\n";

    $OUT .= "        \$res =& \$obj->execute(\$params);\n";

    if ($test->{type} eq 'lib_error') {
        $OUT .= "        \$this->assertTrue(PEAR::isError(\$res), '${name}: isError');\n";
    } elsif ($test->{type} eq 'error') {
        $OUT .= "        \$this->assertFalse(PEAR::isError(\$res), '${name}: isError');\n";
        $OUT .= "        \$data = \$res->getData();\n";
        $OUT .= "        \$this->assertNotNull(\$data, '${name}: getData');\n";
        my $ret_test = [map {['', $_]} @{$method{'error'}->{children}}];
        while (my $ret = shift(@$ret_test)) {
            next if $ret->[1]->{nullable} eq 'true';
            $OUT .= "        \$this->assertObjectHasAttribute('$ret->[1]->{name}', \$data$ret->[0], '${name}: $ret->[1]->{name}');\n";
            $OUT .= "        \$this->assertType('array', \$data$ret->[0]\->$ret->[1]->{name}, '${name}: $ret->[1]->{name}');\n"
                if $ret->[1]->{multiple} eq 'true';
            next unless $ret->[1]->{children};
            my $next_node = $ret->[0].'->'.$ret->[1]->{name};
            $next_node .= '[0]'
                if $ret->[1]->{multiple} eq 'true';
            push(@$ret_test, map {[$next_node, $_]} @{$ret->[1]->{children}});
        }
    } else {
        $OUT .= "        \$this->assertFalse(PEAR::isError(\$res), '${name}: isError');\n";
        $OUT .= "        \$data = \$res->getData();\n";
        $OUT .= "        \$this->assertNotNull(\$data, '${name}: getData');\n";
        my $ret_test = [map {['', $_]} @{$method{'return'}->{children}}];
        while (my $ret = shift(@$ret_test)) {
            next if $ret->[1]->{nullable} eq 'true';
            $OUT .= "        \$this->assertObjectHasAttribute('$ret->[1]->{name}', \$data$ret->[0], '${name}: $ret->[1]->{name}');\n";
            $OUT .= "        \$this->assertType('array', \$data$ret->[0]\->$ret->[1]->{name}, '${name}: $ret->[1]->{name}');\n"
                if $ret->[1]->{multiple} eq 'true';
            next unless $ret->[1]->{children};
            my $next_node = $ret->[0].'->'.$ret->[1]->{name};
            $next_node .= '[0]'
                if $ret->[1]->{multiple} eq 'true';
            push(@$ret_test, map {[$next_node, $_]} @{$ret->[1]->{children}});
        }
    }
} ]%>
    }
}

?>
